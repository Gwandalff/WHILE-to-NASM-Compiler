/*
 * generated by Xtext 2.14.0
 */
package compilateur.nasm.generator

import compilateur.nasm.nasm.Function

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import java.util.TreeSet
import java.util.HashMap

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class NasmGenerator extends AbstractGenerator {
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for (r : resource.allContents.toIterable.filter(Function))
			new NasmGeneratorCodeI().compileI(r)
		ameliorationCodeI
		fsa.generateFile('tableDesSymboles', tableDesSymboles)
		fsa.generateFile('out.asm', NasmGeneratorCodeF.compileASM)
	}
	
	def tableDesSymboles(){
		var res = "Table des fonctions :"
		for (f : Main.fonctions.keySet)
			res += "\n  " + f + " -> " + Main.fonctions.get(f).getName()
		res += "\n\nTable des symboles : ";
		for (String symb : Main.symboles.keySet())
			res+= "\n  " + symb + " -> "+ Main.symboles.get(symb);
		res += "\n\nListe des Ã©tiquettes :"
		for (var i = 0; i < Main.numLab; i++)
			res+= "\n  E" + i;
		for (f : Main.fonctions.keySet){
			res += "\n\n\n----- Fonction " + Main.fonctions.get(f).getName() + " -----\n"
			res += Main.fonctions.get(f).toString()
		}
		res
	}
	
	def ameliorationCodeI(){
		var vars = new HashMap<String,Integer>
		var labels = new TreeSet<String>
		var gotos = new TreeSet<String>
		for (f : Main.fonctions.keySet){
			val fonc = Main.fonctions.get(f)
			val codeInter = fonc.getCodeI
			for (var i = 0; i < codeInter.length; i++){
				var op = codeInter.get(i)
				if (op.getop.split(" ").get(0).equals("LABEL")){
					if (gotos.contains(op.getop.split(" ").get(1)))
						gotos.remove(op.getop.split(" ").get(1))
					else 
						labels.add(op.getop.split(" ").get(1))
				}
				else if (op.getop.split(" ").get(0).equals("GOTO")){
					if (labels.contains(op.getop.split(" ").get(1)))
						labels.remove(op.getop.split(" ").get(1))
					else
						gotos.add(op.getop.split(" ").get(1))
				}		
				else if (op.getop.equals("READ") && labels.isEmpty)
					vars.put(op.getadCible, i)
				else {
					if (vars.keySet.contains(op.getadSource1))
						vars.remove(op.getadSource1)
					if (vars.keySet.contains(op.getadSource2))
						vars.remove(op.getadSource2)
				}
				
			}
			for (var i = fonc.getNbInput; i < codeInter.size - fonc.getNbOutput; i++){
				if (codeInter.get(i).getop.equals("READ") 
					&& vars.keySet.contains(codeInter.get(i).getadCible) 
					&& vars.get(codeInter.get(i).getadCible) - fonc.getCodeImort.length == i){
					var j = i + 1
					var nbReadAfter = 0
					var oneRead = true
					var op = codeInter.get(j).getop
					
					while (op.equals("READ")){
						oneRead = false
						nbReadAfter++
						j++
						op = codeInter.get(j).getop
					}
					j = i - 1
					op = codeInter.get(j).getop
					while (op.equals("READ")){
							oneRead = false
							j--
							op = codeInter.get(j).getop
					}
					
					if (op.split(" ").get(0).equals("CALL")){
						if (!oneRead){
							return
						}
						j--
						op = codeInter.get(j).getop
						while (op.equals("WRITE")){
							j--
							op = codeInter.get(j).getop
						}
						j++
						for (var k = j; k <= i ; k++){
							fonc.addCodeIMort(codeInter.get(j))
							codeInter.remove(j)
						}
					}
					else {
						fonc.addCodeIMort(codeInter.get(j-nbReadAfter))
						codeInter.remove(j-nbReadAfter)
						fonc.addCodeIMort(codeInter.get(i-1))
						codeInter.remove(i-1)
					}
				}
			}
		}
	}
}
