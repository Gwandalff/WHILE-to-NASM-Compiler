/*
 * generated by Xtext 2.14.0
 */
package compilateur.nasm.generator

import compilateur.nasm.Quadruplet
import java.util.List

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class NasmGeneratorCodeF {
	
	static val main = Main.fonctions.get("main")

	static def compileASM() {
		'''		
		section .data
			; CONSTANTES
			NB_VARS		equ		1000
			NB_SYMDESC 	equ 	«Main.numSymb+11»
			SYM_OFFSET	equ		0
			SYM_LENGTH	equ		8
			NB_NODES	equ		1000000
			NODE_USE	equ		0
			NODE_HEAD	equ		8
			NODE_TAIL 	equ		16
			NB_INPUTS	equ		«main.getNbInput»
			NB_OUTPUTS	equ		«main.getNbOutput»
			;; R15		equ		NIL
			;; R14		equ		TRUE
			;; R8		equ		VBP
			;; R9		equ		VSP
			;; R10		equ		ArgPointer
			;; R11  	equ 	ArgPointer
			
			;; DEBUG MODE
			debug		db		«Main.debugMode»
			malloc	  	dw		0
			ralloc		dw		0
			list_size	dw		0
			txt_malloc  db 		"Nombre de demande d'allocation : "
			txt_ralloc  db 		'Nombre de re-allocation de zone memoire : '
			txt_list	db 		'Nombre de noeud encore dans la freelist : '
			
			newline		db		10
			tabulation	db		9
			node_print	db		'@'
			desc_free 	dq 		«(Main.numSymb+1)*16»
			 
			;TABLEAUX
		    symbols_desc	times	NB_SYMDESC*2	dq	0
		    variables_desc	times	NB_VARS			dq	symbols_desc 	
		    sym_free								dq	0
		    node_free								dq	0
		    node_freelist							dq	0
		    fun_buffer		times	128				dq	symbols_desc
		    
		    sym_datas	db	'«Main.createASMSymbols()»'
		
		section .bss
		    argc		resd 	1
		    argv	 	resb	128
		    node_datas	resq	3*NB_NODES
		
		section .text
			global 	_start
		
		_start:
			
			mov		RAX,node_datas	 ; Init the position of the free space for nodes
			mov 	[node_free],RAX
			mov 	[node_freelist],RAX
			«Main.initSymb»
			mov		R15,symbols_desc
			add		[desc_free],R15
			mov		R8,variables_desc
			mov		R9,«(Main.fonctions.get("main").getNbVar()*8)»
			add		R9,R8
			mov		R10,0
			mov		R11,0
			
			mov		RSI,R15
			mov		RDI,R15
			call	cons
			mov 	R14,RBX
			
			call	parseArgs
		
			mov		[malloc], word 0
			mov		[list_size],word 0
			
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			;;           CODE MAIN DU PROGRAMME            ;;
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			«compileCodeFonction(Main.fonctions.get("main").getCodeI)»
			jmp		FIN_PROGRAMME			
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			;;      CODE DES FONCTIONS DU PROGRAMME        ;;
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			«Main.functionsCodeF()»
			
		FIN_PROGRAMME:
			mov		R12,0
			
		writeOutput:
		inc		R12
		mov		RSI,[fun_buffer+R10]
		add		R10,8
		call	head
		mov		RAX,symbols_desc
		add		RAX,16
		cmp		RBX,RAX
		je		writeINT
		add		RAX,16
		cmp		RBX,RAX
		je		writeString
writeBin:
		mov		RAX,0
		call	printBinTree		
		jmp		writeNext
		
writeINT:
		call	tail
		mov		RSI,RBX
		call	binToInt
		call	intToAscii
		mov 	RCX,argv
		mov 	AL, 10
		mov		[RCX + RDX], AL
		inc 	RDX
		call	print
		jmp		writeNext
		
writeString:
		call	tail
		mov		RSI,RBX
		call	printBinString
		mov		RCX,newline
		mov		RDX,1
		call	print
		
writeNext:
		cmp		R12,NB_OUTPUTS
		jl		writeOutput
		
		cmp		byte [debug],0
		je		quit
		
		mov 	RCX,txt_malloc
		mov		RDX,33
		call	print
		mov		EAX,0
		mov		AX, [malloc]
		call	intToAscii
		mov 	RCX,argv
		mov 	AL, 10
		mov		[RCX + RDX], AL
		inc 	RDX
		call	print
		
		mov 	RCX,txt_ralloc
		mov		RDX,42
		call	print
		mov		EAX,0
		mov		AX, [ralloc]
		call	intToAscii
		mov 	RCX,argv
		mov 	AL, 10
		mov		[RCX + RDX], AL
		inc 	RDX
		call	print
		
		mov 	RCX,txt_list
		mov		RDX,42
		call	print
		mov		EAX,0
		mov		AX, [list_size]
		call	intToAscii
		mov 	RCX,argv
		mov 	AL, 10
		mov		[RCX + RDX], AL
		inc 	RDX
		call	print
			
quit:
		mov 	EAX,1            ; The system call for exit (sys_exit)
		mov 	EBX,0            ; Exit with return code of 0 (no error)
		int 	80h;
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; parseArgs : Void -> Void                  ;;
		;;             Void -> Void                  ;;
		;;											 ;;
		;;Get program args, put them in argv, then   ;;
		;;assigne their values to the variables	     ;;
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		parseArgs:
			push 	RBP
			mov 	RBP,RSP
			
			push 	RSI
			push 	RDI
			push 	RDX
			push 	RCX
			push 	RBX
			push 	RAX
			
			mov 	EDX,[RBP+16]		; Get the number of arguments
			mov		[argc],EDX
			
			mov 	RSI,[RBP+24]
			mov 	RDI,0
			mov 	RCX,1				; Set RCX to 1 to delete program name in argv
		
		mvOffset:						; Go after the program name
			add		RSI,1
			mov		BL,[RSI]
			cmp 	BL,0
			jg 		mvOffset
			
		countNul:						; Count the number of null char (args delimiter)
			add		RDI,1				; and the length of the args in RDI
			mov 	BL,[RSI+RDI]
			cmp 	BL,0
			jg 		countNul
			add		RCX,1
			cmp		RCX,[argc]			; When RCX == argc all the args have been read
			jl		countNul
			
			sub		RDI,2
			inc		RSI
			
			mov		RBX,argv
			call	cpStr
			
			mov		RSI,argv
			mov		RDI,0
			mov		ECX,[argc]
			dec		ECX
			mov		RBX,0
			
		argsProcess:
				cmp		RBX,NB_INPUTS
				je		argEnd
				push	RBX
				
			findLength:
				inc		RDI
				mov		AL,[RSI+RDI]
				cmp		AL,0
				jne		findLength
				push	RDI
			
				mov		AL,[RSI]
				sub		AL,'0'					; warning if char is before '0' negative value
				cmp		AL,10					; to catch this error we need to work on unsigned values
				jb		intArg					; jb is AL < 10 but the values are unsigned
				
				mov		AL,[RSI]
				sub		AL,'a'					; warning if char is before 'a' negative value
				cmp		AL,26					; to catch this error we need to work on unsigned values
				jb		symbArg					; jb is AL < 10 but the values are unsigned
				
				call 	parseCons
				mov		[R11+fun_buffer],RBX
				add		R11,8
				jmp		nextArg
			jumpRepeat:
				jmp		argsProcess
				
			intArg:
				call	asciiToInt
				call	intToBin
				mov		[R11+fun_buffer],RBX
				add		R11,8
				jmp		nextArg
				
			symbArg:
				call	addSym
				mov		[R11+fun_buffer],RBX
				add		R11,8
				jmp		nextArg
			
			nextArg:
			
				mov		RAX,node_datas				; Is symbol ?
				cmp		RBX,RAX
				jl		endArgLoop
				inc		qword [RBX+NODE_USE]
				
			endArgLoop:
				pop		RDI
				add		RSI,RDI
				inc		RSI
				mov		RDI,0
				pop		RBX
				inc		RBX
				loop	jumpRepeat
				
		argEnd:
			pop 	RAX
			pop 	RBX
			pop 	RCX
			pop 	RDX
			pop 	RDI
			pop 	RSI
			
			mov 	RSP,RBP
			pop 	RBP
			ret
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; asciiToInt : Address X Length -> Value    ;;
		;;          	RSI     X RDI    -> RAX      ;;
		;;											 ;;
		;;Convert the number at {Address} in ascii   ;;
		;;Return the value of this ascii number      ;;
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		asciiToInt:
			push 	RBP
			mov 	RBP,RSP
			
			push	RBX
			push 	RCX
			push 	RDX
			push	RDI
			
			mov		RDX,0
			mov		RBX,1
			mov		RCX,0
			dec		RDI
		
			mov		RAX,RBX
		nextNumber:	
			cmp		RDI,0
			jl		atoi_end
			mov		DL,[RSI+RDI]
			sub		DL,'0'
			mul		DX
			add		RCX,RAX
			mov		RAX,10
			mul		BX
			mov		RBX,RAX
			dec		RDI
			jmp		nextNumber
		atoi_end:
			mov		RAX,RCX
			
			pop		RDI
			pop		RDX
			pop		RCX
			pop		RBX
			
			mov 	RSP,RBP
			pop 	RBP
			ret
			
			
			
			
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; intToAscii : Value -> Length              ;;
		;;          	EAX   -> RDX                 ;;
		;;											 ;;
		;;Convert the number {Value} in ascii        ;;
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		intToAscii:
			push 	RBP
			mov 	RBP,RSP
			
		    mov 	ECX, 10         ; divisor
		    xor 	BX, BX          ; count digits
		    mov		RSI,argv
		
		divide:
		    xor 	EDX,EDX        	; high part = 0
		    div 	ECX             ; eax = edx:eax/ecx, edx = remainder
		    push 	DX            	; DL is a digit in range [0..9]
		    inc 	BX              ; count digits
		    cmp 	EAX, 0       	; EAX is 0?
		    jnz 	divide          ; no, continue
		
		    						; POP digits from stack in reverse order
		    mov 	CX,BX          	; number of digits
		    mov		RDX,0
		    mov		DX,BX
		next_digit:
		    pop 	AX
		    add 	AL, '0'         ; convert to ASCII
		    mov 	[RSI], AL       ; write it to the buffer
		    inc 	RSI
		    loop 	next_digit
		    
		    mov 	RSP,RBP
			pop 	RBP
			ret
			
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; parseCons : Address X Length -> Address   ;;
		;;             RSI     X RDI    -> RBX       ;;
		;;											 ;;
		;;parse a string which represent a binTree   ;;
		;;return {Address} of the binTree            ;;
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		parseCons:
			push 	RBP
			mov 	RBP,RSP
					
			push	R12
			push	RAX
			push	RCX
			
			mov		R12,0
			mov		RCX,0
			dec		RDI
			pbt_nextarg:
				inc		R12
				cmp		R12,RDI
				jge		pbt_fin
				mov		AL,[RSI+R12]
				cmp		AL,' '
				jne		pbt_nextarg
				
			inc		R12
			inc		RCX
			mov		AL,[RSI+R12]
			cmp		AL,'('
			je		pbt_cons
			
			push 	RDI
			push 	RSI
			mov		RDI,0
			add		RSI,R12
			
			pbt_findsymlen:
				inc		RDI
				mov		AL,[RSI+RDI]
				cmp		AL,')'
				je		pbt_finsym
				cmp		AL,' '
				je		pbt_finsym
				jmp		pbt_findsymlen
		pbt_finsym:
			push	RDI
			push	R12
			call	addSym
			pop		R12
			pop		RDI
			dec 	RDI
			add		R12,RDI
			pop		RSI
			pop		RDI
			push	RBX
			jmp		pbt_nextarg
			
		pbt_cons:
			push 	RDI
			push 	RSI
			mov		R13,1
			mov		RDI,0
			add		RSI,R12
			pbt_findend:
				inc		RDI
				mov		AL,[RSI+RDI]
				cmp		AL,'('
				je		pbt_parinc
				cmp		AL,')'
				jne		pbt_findend
				dec		R13
				cmp		R13,0
				jne		pbt_findend
				jmp		pbt_fincons
			pbt_parinc:
				inc		R13
				jmp		pbt_findend
		pbt_fincons:
			push	RDI
			inc		RDI
			call	parseCons
			pop		RDI
			pop		RSI
			add		R12,RDI
			pop		RDI
			push	RBX
			jmp		pbt_nextarg
			
		pbt_fin:
			cmp		RCX,2
			jge		pbt_chaincons
			pop		RBX
			jmp		pbt_postlude
		pbt_chaincons:
			dec		RCX
			pop		RDI
			pbt_chainloop:
				pop		RSI
				call 	cons
				mov		RDI,RBX
				loop	pbt_chainloop
			
		pbt_postlude:
			inc		RDI
			pop		RCX
			pop		RAX
			pop		R12
						
			mov 	RSP,RBP
			pop 	RBP
			ret
			
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; addSym : Address X Length -> Address      ;;
		;;          RSI     X RDI    -> RBX          ;;
		;;											 ;;
		;;Add a Symbol of {Length} ascii from        ;;
		;;{Address} and return {Address} of the desc ;;
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		addSym:
			push 	RBP
			mov 	RBP,RSP
			
			push	RAX
			
			push	RDI			
			mov		RBX,symbols_desc
			
		checkExist:
			cmp		RDI,[RBX+SYM_LENGTH]
			jne		nextSymbol
			dec		RDI
		
		nextChar:
			mov		RAX,[RBX+SYM_OFFSET]
			mov		AL,[sym_datas+RAX+RDI]
			cmp		AL,[RSI+RDI]
			jne		nextSymbol
			cmp		RDI,0
			je		addSym_end
			dec		RDI
			jmp		nextChar
			
		nextSymbol:
			pop		RDI
			push	RDI
			add		RBX,16
			cmp		RBX,[desc_free]
			jl		checkExist
			
			pop		RDI
			dec		RDI
			mov 	RBX,[sym_free]
			call	cpStr
			inc		RDI
			mov		R12,[sym_free]
			sub		R12,sym_datas
			mov		R13,[desc_free]
			mov		[R13+SYM_OFFSET],R12
			mov		[R13+SYM_LENGTH],RDI
			mov 	R12,16
			mov		RBX,[desc_free]
			add		[desc_free],R12
			add		[sym_free],RDI
			
		addSym_end:
			pop		RAX
			
			mov 	RSP,RBP
			pop 	RBP
			ret
			
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; binToInt : Address -> IntValue            ;;
		;;            RSI     -> RAX                 ;;
		;;											 ;;
		;;Return value of the BinTree at {Address}   ;;
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		binToInt:
			push 	RBP
			mov 	RBP,RSP
			
			mov 	RAX,0
		bttoi:
			cmp		RSI,node_datas
			jl		bttoi_end
			call	tail
			mov		RSI,RBX
			inc		RAX
			jmp		bttoi
		bttoi_end:
			mov 	RSP,RBP
			pop 	RBP
			ret
			
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; intToBin : IntValue -> Address            ;;
		;;            RAX      -> RBX                ;;
		;;											 ;;
		;;Return a BinTree {Address} of {IntValue}   ;;
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		intToBin:
			push 	RBP
			mov 	RBP,RSP
			
			push	RSI
			push	RDI
			
			mov		RSI,R15
			mov		RDI,R15
			mov		RBX,R15
		
		itobt:
			cmp		RAX,0
			jle		itobt_end
			call	cons
			mov 	RDI,RBX
			dec		RAX
			jmp		itobt
			
		itobt_end:
			pop		RDI
			pop		RSI
		
			mov 	RSP,RBP
			pop 	RBP
			ret
			
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; printBinString : Address -> void          ;;
		;;            	    RSI     -> void          ;;
		;;											 ;;
		;;Print the concatenation of the symbol in   ;;
		;;the BinTree at {Address}                   ;;
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		printBinString:
			push 	RBP
			mov 	RBP,RSP
			
			cmp 	RSI,node_datas
			jge		pbs_node
			mov		RCX,[RSI+SYM_OFFSET]
			add		RCX,sym_datas
			mov		RDX,[RSI+SYM_LENGTH]
			call	print
			jmp		pbs_end
			
		pbs_node:
			push	RSI
			call	head
			mov		RSI,RBX
			call	printBinString
			pop		RSI
			call	tail
			mov		RSI,RBX
			call	printBinString
		
		pbs_end:
			mov 	RSP,RBP
			pop 	RBP
			ret
			
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; printBinTree : Address X Tab -> void      ;;
		;;                RSI     X RAX -> void      ;;
		;;											 ;;
		;;Print the BinTree at {Address}             ;;
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		printBinTree:
			push 	RBP
			mov 	RBP,RSP
			
			push	RBX
			push	RCX
			push 	RDX
			
			mov		RBX,0
			
		tabulate:
			cmp		RAX,RBX
			je		pbt_process
			mov		RCX,tabulation
			mov		RDX,1
			call	print
			inc		RBX
			jmp		tabulate
			
		pbt_process:
			cmp 	RSI,node_datas
			jge		pbt_node
			mov		RCX,[RSI+SYM_OFFSET]
			add		RCX,sym_datas
			mov		RDX,[RSI+SYM_LENGTH]
			call	print
			mov		RCX,newline
			mov		RDX,1
			call	print
			jmp		pbt_end
			
		pbt_node:
			mov		RCX,node_print
			mov		RDX,1
			call	print
			mov		RCX,newline
			mov		RDX,1
			call	print
			inc 	RAX
			push	RAX
			push	RSI
			call	head
			mov		RSI,RBX
			call	printBinTree
			pop		RSI
			pop		RAX
			call	tail
			mov		RSI,RBX
			call	printBinTree
		
		pbt_end:
			pop		RDX
			pop		RCX
			pop		RBX
		
			mov 	RSP,RBP
			pop 	RBP
			ret
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; print : Address X Length -> Void          ;;
		;;         RCX     X RDX    -> Void          ;;
		;;											 ;;
		;;Print the {Length}-th ascii from {Address} ;;
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		print:
			push 	RBP
			mov 	RBP,RSP
			
			push	R10
			push	RAX
			push	RBX
			
			mov 	EAX,4            ; The system call for write (sys_write)
			mov 	EBX,1            ; File descriptor 1 - standard output
			int 	80h              ; Call the kernel
			
			pop		RBX
			pop		RAX
			pop		R10
			
			mov 	RSP,RBP
			pop 	RBP
			ret
			
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; cpStr : Address X Length X Copy -> Void   ;;
		;;         RSI     X RDI    X RBX  -> Void   ;;
		;;											 ;;
		;;Copy the {Length}-th bytes from {Address}  ;;
		;;at {Copy}                                  ;;
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
		cpStr:
			push 	RBP
			mov 	RBP,RSP
			
			push 	RDX	
			push	RCX
			
			mov 	RCX,0
		    
		cpLoop:						; loop for copy
			mov 	DL,[RSI+RCX]
			mov 	[RBX+RCX],DL
			add 	RCX,1
			cmp		RDI,RCX
			jge		cpLoop
			
			pop		RCX
			pop 	RDX
			
			mov 	RSP,RBP
			pop 	RBP
			ret
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; cleanFun : Void 	-> Void					 ;;
		;;            Void 	-> Void					 ;;
		;;											 ;;
		;;Clean the memory after a function  		 ;;
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		cleanFun:
			push 	RBP
			mov 	RBP,RSP
			
			push 	RSI
			push 	RAX
			
			mov		RSI,0
			mov		RAX,R9
			sub		RAX,R8
			
		clean_loop:
			cmp		RSI,RAX
			jge		clean_fin
			
			mov		[R8+RSI],R15
			
			add		RSI,8
			jmp 	clean_loop
			
		clean_fin:
			pop 	RAX
			pop 	RSI
			
			mov 	RSP,RBP
			pop 	RBP
			ret	
			
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; chgVar : Index 	-> Void					 ;;
		;;          RSI  	-> Void					 ;;
		;;											 ;;
		;;{ Index } of the var which is gonna change ;;
		;;Dec use of the node and handle the 0 use   ;;
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		chgVar:
			push 	RBP
			mov 	RBP,RSP
			
			push 	RBX
			push 	RAX
			
			mov		RBX,[R8+RSI]
			
			mov		RAX,node_datas				; Is symbol ?
			cmp		RBX,RAX
			jl		chgVar_end						; If yes nothing to clean
			
			call	decNodeUse
			
			cmp		RAX,0
			jne		chgVar_end
			
			inc		word [list_size]
			mov 	RAX,[node_freelist]
			mov		[RBX+NODE_USE],RAX
			mov		[node_freelist],RBX
			
		chgVar_end:
			
			pop 	RAX
			pop 	RBX
			
			mov 	RSP,RBP
			pop 	RBP
			ret	
			
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; decNodeUse : Node -> Integer				 ;;
		;;            	RBX  -> RAX				     ;;
		;;											 ;;
		;;Update the number of use in the BinTree RBX;;
		;;Return number of use after dec			 ;;
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		decNodeUse:
			
			mov		RAX,[RBX+NODE_USE]
			dec		RAX
			mov		[RBX+NODE_USE],RAX
			
			ret
		
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; delMem : Node -> address				     ;;
		;;          RBX  -> RCX					     ;;
		;;											 ;;
		;;Delete { Node } and handle its head and    ;;
		;;tail return pointer to the updated freelist;;
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		delMem:
			push 	RBP
			mov 	RBP,RSP
			
			push 	RDX
			push 	RAX
			
			mov		RCX,[RBX+NODE_USE]
			mov		[node_freelist],RCX
			dec		word [list_size]
			
			mov		RDX,RBX
			mov		RBX,[RDX+NODE_TAIL]
			mov		RAX,node_datas				; Is symbol ?
			cmp		RBX,RAX
			jl		delMem_head						; If yes nothing to clean
			
			call	decNodeUse
			cmp		RAX,0
			jne		delMem_head
			
			inc		word [list_size]
			mov		[RBX+NODE_USE],RCX
			mov		RCX,RBX
			
		delMem_head:
			mov		RBX,[RDX+NODE_HEAD]
			mov		RAX,node_datas				; Is symbol ?
			cmp		RBX,RAX
			jl		update_freelist						; If yes nothing to clean
			
			call	decNodeUse
			cmp		RAX,0
			jne		update_freelist
			
			inc		word [list_size]
			mov		[RBX+NODE_USE],RCX
			mov		RCX,RBX
			
		update_freelist:
			mov		[node_freelist],RCX
			
			mov		RBX,RDX
			
			pop 	RAX
			pop 	RDX
			
			mov 	RSP,RBP
			pop 	RBP
			ret	
			
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; cons : Head X Tail -> Address             ;;
		;;        RSI  X RDI  -> RBX			     ;;
		;;											 ;;
		;;Create a new node with {Head} and {Tail}   ;;
		;;Return the new node {Address}              ;;
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
		cons:
			push 	RBP
			mov 	RBP,RSP
			
			push 	RAX
			
			inc		word [malloc]
			
			mov		RAX,node_datas
			cmp		RSI,RAX
			jl		cons_incTail
			
			mov 	RBX,[RSI+NODE_USE]					; Update number of use for head
			inc		RBX
			mov		[RSI+NODE_USE],RBX
		cons_incTail:
			cmp		RDI,RAX
			jl		cons_create
			mov 	RBX,[RDI+NODE_USE]					; Update number of use for tail
			inc		RBX
			mov		[RDI+NODE_USE],RBX		
			
		cons_create:
			mov		RBX,[node_freelist]						; Get address for the new node
			cmp		RBX,[node_free]
			je		cons_fin_list
			
			call 	delMem
			inc		word [ralloc]
			mov 	RAX,0
			mov		[RBX+NODE_USE],RAX
			mov		[RBX+NODE_HEAD],RSI
			mov		[RBX+NODE_TAIL],RDI
			jmp		cons_post
			
		cons_fin_list:
			mov 	RAX,0
			mov		[RBX+NODE_USE],RAX
			mov		[RBX+NODE_HEAD],RSI
			mov		[RBX+NODE_TAIL],RDI
			
			add 	RBX,24
			mov		[node_freelist],RBX
			mov		[node_free],RBX
			sub		RBX,24
			
		cons_post:
			pop 	RAX
			
			mov 	RSP,RBP
			pop 	RBP
			ret
		
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; head : Address -> Head                    ;;
		;;        RSI     -> RBX			         ;;
		;;											 ;;
		;;Return the {Head} of the node at {Address} ;;
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
		head:
			push 	RBP
			mov 	RBP,RSP
			
			push 	RAX
			
			mov		RAX,node_datas
			cmp		RSI,RAX
			jge		head_node
			mov		RBX,R15
			jmp		head_end
		head_node:
			mov		RBX,[RSI+NODE_HEAD]
		head_end:	
			pop 	RAX
			
			mov 	RSP,RBP
			pop 	RBP
			ret
			
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; tail : Address -> Tail                    ;;
		;;        RSI     -> RBX			         ;;
		;;											 ;;
		;;Return the {Tail} of the node at {Address} ;;
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
		tail:
			push 	RBP
			mov 	RBP,RSP
			
			push 	RAX
			
			mov		RAX,node_datas
			cmp		RSI,RAX
			jge		tail_node
			mov		RBX,R15
			jmp		tail_end
		tail_node:
			mov		RBX,[RSI+NODE_TAIL]
		tail_end:	
			pop 	RAX
			
			mov 	RSP,RBP
			pop 	RBP
			ret
			
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; read : Offset -> Void                     ;;
		;;        RSI    -> Void			         ;;
		;;											 ;;
		;;Copy the arg on top of the func_buffer     ;;
		;;In the var {offset}						 ;;
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
		read:
			push 	RBP
			mov 	RBP,RSP
			
			push	RAX
			push	RBX
			
			call 	chgVar
			
			mov		R11,0
			
			mov		RAX,[R10+fun_buffer]
			mov		[R8+RSI],RAX
			add		R10,8
			
		read_end:
			pop		RBX
			pop		RAX
			
			mov 	RSP,RBP
			pop 	RBP
			ret
			
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; write : Offset -> Void                    ;;
		;;         RSI    -> Void			         ;;
		;;											 ;;
		;;Copy the var {RSI} at the top of fun_buffer;;
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
		write:
			push 	RBP
			mov 	RBP,RSP
			
			push	RAX
			
			mov		R10,0
			
			mov		RAX,[R8+RSI]
			mov		[R11+fun_buffer],RAX
			add		R11,8
			
			mov		RBX,node_datas				; Is symbol ?
			cmp		RAX,RBX
			jl		write_end
			mov		RBX,[RAX+NODE_USE]
			inc		RBX
			mov		[RAX+NODE_USE],RBX
			
		write_end:
			pop		RAX
			
			mov 	RSP,RBP
			pop 	RBP
			ret
			
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;; equals : Var1 X Var2 -> Equals            ;;
		;;          RSI  X RDI  -> RAX		         ;;
		;;											 ;;
		;;return 1 if Var1=Var2 else 0				 ;;
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
		equals:
			push 	RBP
			mov 	RBP,RSP
			
			cmp 	RSI,node_datas
			jge		eq_nodeV1
			cmp 	RDI,node_datas
			jge		eq_zero
			cmp		RSI,RDI
			je		eq_un
			jmp		eq_zero
		eq_nodeV1:
			cmp 	RDI,node_datas
			jl		eq_zero
			
			push 	RSI
			push 	RDI
			
			mov		RSI,[RSI+NODE_HEAD]
			mov		RDI,[RDI+NODE_HEAD]
			call	equals
			
			pop		RDI
			pop		RSI
			
			cmp		RAX,0
			je		eq_zero
			
			mov		RSI,[RSI+NODE_TAIL]
			mov		RDI,[RDI+NODE_TAIL]
			call	equals
			cmp		RAX,0
			je		eq_zero
		eq_un:
			mov		RAX,1
			jmp		eq_end
		
		eq_zero:
			mov		RAX,0
		
		eq_end:
			mov 	RSP,RBP
			pop 	RBP
			ret
		'''
	}
	
	def static compileCodeFonction(List<Quadruplet> codeI){
		var res = ""
		var nbVar = 0
		var nbSymb = 0
		for (op : codeI){
			res += ";; " + op.toString + "\n"
			var operation = op.getop.split(" ")
			switch (operation.get(0)) {
				case "READ":{
					nbVar = (Integer.parseInt(op.getadCible.substring(1))-1)*8
					res += "mov		RSI," + nbVar + "\n" 
					res += "call 	read\n"
				}
				case "WRITE":{
					nbVar = (Integer.parseInt(op.getadSource1.substring(1))-1)*8
					res += "mov		RSI," + nbVar + "\n"
					res += "call 	write\n"
				}
				case "NOP":
					res += "nop\n"
				case "NIL":{
					nbVar = (Integer.parseInt(op.getadCible.substring(1))-1)*8
					res += "mov		[R8+" + nbVar + "],R15\n"
				}
				case "TRUE":{
					nbVar = (Integer.parseInt(op.getadCible.substring(1))-1)*8
					res += "mov		[R8+" + nbVar + "],R14\n"
				}
				case "CONS":{
					nbVar = (Integer.parseInt(op.getadSource1.substring(1))-1)*8
					res += "mov		RSI,[R8+" + nbVar + "]\n"
					nbVar = (Integer.parseInt(op.getadSource2.substring(1))-1)*8
					res += "mov		RDI,[R8+" + nbVar + "]\n"
					res += "call 	cons\n"
					//res += "inc 	qword [RBX+NODE_USE]\n"
					nbVar = (Integer.parseInt(op.getadCible.substring(1))-1)*8
					res += "mov		[R8+" + nbVar + "],RBX\n"
				}
				case "HEAD":{
					nbVar = (Integer.parseInt(op.getadSource1.substring(1))-1)*8
					res += "mov		RSI,[R8+" + nbVar + "]\n"
					res += "call 	head\n"
					nbVar = (Integer.parseInt(op.getadCible.substring(1))-1)*8
					res += "mov		[R8+" + nbVar + "],RBX\n"
				}
				case "TAIL":{
					nbVar = (Integer.parseInt(op.getadSource1.substring(1))-1)*8
					res += "mov		RSI,[R8+" + nbVar + "]\n"
					res += "call 	tail\n"
					nbVar = (Integer.parseInt(op.getadCible.substring(1))-1)*8
					res += "mov		[R8+" + nbVar + "],RBX\n"
				}
				case "LABEL":{
					res += "." + operation.get(1) + ":\n"
				}
				case "IFNZ":{
					nbVar = (Integer.parseInt(op.getadSource1.substring(1))-1)*8
					res += "cmp		R15,[R8+" + nbVar + "]\n"
					res += "jnz		." + operation.get(1) + "\n"
				}
				case "IFNEQ":{
					nbVar = (Integer.parseInt(op.getadSource1.substring(1))-1)*8
					res += "mov		RSI,[R8+" + nbVar + "]\n"
					nbVar = (Integer.parseInt(op.getadSource2.substring(1))-1)*8
					res += "mov		RDI,[R8+" + nbVar + "]\n"
					res += "call	equals\n"
					res += "cmp		RAX,0\n"
					res += "je		." + operation.get(1) + "\n"
				}
				case "GOTO":{
					res += "jmp		." + operation.get(1) + "\n"
				}
				case "SYMB":{
					nbSymb = (Integer.parseInt(operation.get(1).substring(1)))*16
					nbVar = (Integer.parseInt(op.getadCible.substring(1))-1)*8
					res += "mov		R12," + nbSymb + "\n"
					res += "add		R12,symbols_desc\n"
					res += "mov		[R8+" + nbVar + "],R12\n"
				}
				case "CALL":{
					res += "call		" + operation.get(1) + "\n"
				}
				default:{}
			}
		}
		res
	}
}
